<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Clutch King - Randomized Checkpoints</title>
  <style>
    body { background: #222; color: #fff; font-family: sans-serif; }
    #gameCanvas { background: #111; display: block; margin: 20px auto; border: 2px solid #fff; }
    #info { text-align: center; margin-top: 10px; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1200" height="200"></canvas>
  <div id="info"></div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // SETTINGS
    const TRACK_LENGTH = 1000; // The finish line is at x=TRACK_LENGTH (pushed further)
    const NUM_CHECKPOINTS = 6;
    const PLAYER_RADIUS = 15;
    const PLAYER_COLOR = '#4caf50';
    const CHECKPOINT_COLOR = '#ff9800';
    const FINISH_COLOR = '#f44336';
    const START_COLOR = '#2196f3';
    const PLAYER_SPEED = 4;
    const CHECKPOINT_RADIUS = 18;
    const MIN_SPACING = 120; // Minimum distance between checkpoints, start, and finish

    // Generate randomized, well-spaced checkpoint positions
    function generateCheckpoints(startX, finishX, num, minSpacing) {
      const positions = [];
      // Divide the track into (num+1) segments, pick a random point in each segment for checkpoint
      const segment = (finishX - startX) / (num + 1);
      for (let i = 1; i <= num; i++) {
        let min = startX + segment * (i - 1) + minSpacing/2;
        let max = startX + segment * i - minSpacing/2;
        if (min > max) min = max - 1;
        // Random position in this segment
        const pos = Math.floor(Math.random() * (max - min + 1)) + min;
        positions.push(pos);
      }
      return positions;
    }

    function resetGame() {
      // Start and finish positions
      gameState.startX = 60;
      gameState.finishX = TRACK_LENGTH + 60;

      // Generate checkpoint positions
      gameState.checkpoints = generateCheckpoints(gameState.startX, gameState.finishX, NUM_CHECKPOINTS, MIN_SPACING);
      gameState.checkpointsHit = Array(NUM_CHECKPOINTS).fill(false);
      gameState.playerX = gameState.startX;
      gameState.finished = false;
      gameState.startTime = null;
      gameState.endTime = null;
      gameState.requestedFrame = null;
      gameState.currentCheckpoint = 0;
      drawGame();
    }

    let gameState = {
      startX: 60,
      finishX: TRACK_LENGTH + 60,
      checkpoints: [],
      checkpointsHit: [],
      playerX: 60,
      finished: false,
      startTime: null,
      endTime: null,
      requestedFrame: null,
      currentCheckpoint: 0
    };

    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw track
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(gameState.startX, canvas.height/2);
      ctx.lineTo(gameState.finishX, canvas.height/2);
      ctx.stroke();

      // Draw checkpoints
      gameState.checkpoints.forEach((x, i) => {
        ctx.beginPath();
        ctx.arc(x, canvas.height/2, CHECKPOINT_RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = gameState.checkpointsHit[i] ? '#ffd54f' : CHECKPOINT_COLOR;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#000';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText((i+1), x, canvas.height/2);
      });

      // Draw finish line
      ctx.strokeStyle = FINISH_COLOR;
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(gameState.finishX, canvas.height/2 - 42);
      ctx.lineTo(gameState.finishX, canvas.height/2 + 42);
      ctx.stroke();
      ctx.fillStyle = FINISH_COLOR;
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Finish', gameState.finishX, canvas.height/2 - 48);

      // Draw start line
      ctx.strokeStyle = START_COLOR;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(gameState.startX, canvas.height/2 - 34);
      ctx.lineTo(gameState.startX, canvas.height/2 + 34);
      ctx.stroke();
      ctx.font = 'bold 18px sans-serif';
      ctx.fillStyle = START_COLOR;
      ctx.fillText('Start', gameState.startX, canvas.height/2 - 36);

      // Draw player
      ctx.beginPath();
      ctx.arc(gameState.playerX, canvas.height/2, PLAYER_RADIUS, 0, 2 * Math.PI);
      ctx.fillStyle = PLAYER_COLOR;
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function gameLoop() {
      drawGame();
      if (!gameState.finished) {
        gameState.requestedFrame = requestAnimationFrame(gameLoop);
      }
    }

    function showInfo(msg) {
      document.getElementById('info').innerHTML = msg;
    }

    function updateInfo() {
      if (!gameState.finished) {
        showInfo(`Checkpoint: ${gameState.currentCheckpoint+1}/${NUM_CHECKPOINTS} &nbsp;&nbsp; | &nbsp;&nbsp; Use Right Arrow or D to move!`);
      } else {
        showInfo(`Finished! Time: ${((gameState.endTime - gameState.startTime)/1000).toFixed(2)}s &nbsp;&nbsp; <button onclick="resetGame(); updateInfo(); cancelAnimationFrame(gameState.requestedFrame); gameLoop();">Play Again</button>`);
      }
    }

    function nextCheckpointX() {
      if (gameState.currentCheckpoint < NUM_CHECKPOINTS) {
        return gameState.checkpoints[gameState.currentCheckpoint];
      } else {
        return gameState.finishX;
      }
    }

    // Handle player movement and checkpoint logic
    document.addEventListener('keydown', function(e) {
      if (gameState.finished) return;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        if (gameState.startTime === null) gameState.startTime = performance.now();
        let oldX = gameState.playerX;
        gameState.playerX = Math.min(gameState.playerX + PLAYER_SPEED, gameState.finishX);

        // Check for reaching current checkpoint
        if (gameState.currentCheckpoint < NUM_CHECKPOINTS) {
          let checkX = gameState.checkpoints[gameState.currentCheckpoint];
          if ((oldX < checkX && gameState.playerX >= checkX) ||
              Math.abs(gameState.playerX - checkX) < PLAYER_RADIUS+CHECKPOINT_RADIUS) {
            gameState.checkpointsHit[gameState.currentCheckpoint] = true;
            gameState.currentCheckpoint++;
          }
        }

        // Check for reaching finish
        if (gameState.currentCheckpoint === NUM_CHECKPOINTS &&
            (oldX < gameState.finishX && gameState.playerX >= gameState.finishX)) {
          gameState.finished = true;
          gameState.endTime = performance.now();
        }
        updateInfo();
        drawGame();
      }
    });

    // Initial setup
    resetGame();
    updateInfo();
    gameLoop();
  </script>
</body>
</html>
